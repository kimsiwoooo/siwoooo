import sys
import os
import numpy as np
import pandas as pd
import json,pickle
import networkx as nx
from math import sqrt
from random import shuffle
from collections import OrderedDict
from scipy import stats
from IPython.display import SVG
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.nn import Sequential, Linear, ReLU
from rdkit import Chem
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import rdDepictor
from rdkit.Chem.Draw import rdMolDraw2D
from rdkit.Chem import MolFromSmiles

# 시각화 라이브러리
from matplotlib import pyplot as plt
import seaborn as sns

def one_of_k_encoding(x, allowable_set):
    if x not in allowable_set:
        raise Exception("input {0} not in allowable set{1}:".format(x, allowable_set))
    return list(map(lambda s: x == s, allowable_set))

def one_of_k_encoding_unk(x, allowable_set):
    """Maps inputs not in the allowable set to the last element."""
    if x not in allowable_set:
        x = allowable_set[-1]
    return list(map(lambda s: x == s, allowable_set))

def atom_features(atom):
    return np.array(one_of_k_encoding_unk(atom.GetSymbol(),['C', 'N', 'O', 'S', 'F', 'Si', 'P', 'Cl', 'Br', 'Mg', 'Na','Ca', 'Fe', 'As', 'Al', 'I', 'B', 'V', 'K', 'Tl', 'Yb','Sb', 'Sn', 'Ag', 'Pd', 'Co', 'Se', 'Ti', 'Zn', 'H','Li', 'Ge', 'Cu', 'Au', 'Ni', 'Cd', 'In', 'Mn', 'Zr','Cr', 'Pt', 'Hg', 'Pb', 'Unknown']) +
                    one_of_k_encoding(atom.GetDegree(), [0, 1, 2, 3, 4, 5, 6,7,8,9,10]) +
                    one_of_k_encoding_unk(atom.GetTotalNumHs(), [0, 1, 2, 3, 4, 5, 6,7,8,9,10]) +
                    one_of_k_encoding_unk(atom.GetImplicitValence(), [0, 1, 2, 3, 4, 5, 6,7,8,9,10]) +
                    [atom.GetIsAromatic()])


# Returns : 원자 개수, 원자 특성 행렬, 인접 행렬
def smile_to_graph(smile):
    # SMILES 문자열로부터 분자 그래프 데이터 생성
    mol = Chem.MolFromSmiles(smile)

    # mol.GetNumAtoms() : 분자에 소속되어 있는 원자의 개수
    c_size = mol.GetNumAtoms()

    features = []
    # 분자에 소속되어 있는 원자들을 순회하면서 원자 특성 정보 수집
    for atom in mol.GetAtoms():
        feature = atom_features(atom)
        # 정규화?
        features.append(feature / sum(feature))
    # features_ar = np.array(features)
    # features_arr = np.pad(features_ar, pad_width = ((0,0), (0,0)), mode="constant", constant_values=0)
    edges = []
    # 분자를 이루는 원자들의 연결 구조 정보를 순회하면서 인접 정보 수집
    # 연결 구조 정보 : 시작 원자 index, 끝 원자 index
    for bond in mol.GetBonds():
        edges.append([bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()])

    # 연결 구조 정보를 통한 방향 그래프 생성
    g = nx.Graph(edges).to_directed()
    edge_index = []
    for e1, e2 in g.edges:
        edge_index.append([e1, e2])
    # edge_index_ar = np.array(edge_index)
    # edge_index_arr = np.pad(edge_index_ar, pad_width = ((4,4), (0,0)), mode="constant", constant_values=0)

    return c_size, features, edge_index

#cmpd = pd.read_csv('/content/drive/MyDrive/cmpd.csv')

cmpd_test = pd.read_excel('C:/Users/Kim Siwoo/Desktop/cmpd_test.xlsx')
cmpd_train = pd.read_excel('C:/Users/Kim Siwoo/Desktop/cmpd_train.xlsx')

mol_list_train = []
for smi in cmpd_train["smiles"]:
    smi_graph = smile_to_graph(smi)
    mol_list_train.append(smi_graph)

mol_list_test = []
for smi in cmpd_test["smiles"]:
    smi_graph = smile_to_graph(smi)
    mol_list_test.append(smi_graph)

max_len = max(len(item) for item in mol_list_train)

from sklearn.preprocessing import LabelEncoder
label_list_train = []
for i in cmpd_train["activity"]:
    label_list_train.append(i)

label_list_test = []
for z in cmpd_test["activity"]:
    label_list_test.append(z)

encoder = LabelEncoder()
encoder.fit(label_list_train)
encoder.fit(label_list_test)
labels_train = encoder.transform(label_list_train)
labels_test = encoder.transform(label_list_test)
#print(labels_train)
train_mol = np.array(mol_list_train, dtype=object)
test_mol = np.array(mol_list_test, dtype=object)
print(test_mol[1])
# print(train_mol[0])
from sklearn.ensemble import RandomForestClassifier as RFC
model = RFC(n_estimators=10, max_depth=5)
model.fit(train_mol, labels_train)
